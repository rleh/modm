/*
 * Copyright (c) 2018, Christopher Durand
 * Copyright (c) 2018, Raphael Lehmann
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#include "dmahal.hpp"

using Interface = modm::platform::DmaHalSlotInterface;

%% if target["family"] == "f4"
	%% set slots = range(0,8)
%% elif target["family"] == "f3"
	%% if id == 1
		%% set slots = range(1,7)
	%% elif id == 2
		%% set slots = range(1,5)
	%% endif
%% endif

%% for slot_id in slots

%% set instance = "DMA" ~ id
// if type == "stm32-stream-channel"
%% if target["family"] == "f4"
	%% set slot = instance ~ "_Stream" ~ slot_id
	%% set reg = slot ~ "->CR"
	%% set mem = slot ~ "->M0AR"
	%% set per = slot ~ "->PAR"
	%% set length = slot ~ "->NDTR"
	%% set prefix = "DMA_SxCR"
// if type == "stm32-channel-request"
%% elif target["family"] == "f3" or target["family"] == "l4"
	%% set slot = instance ~ "_Channel" ~ slot_id
	%% set reg = slot ~ "->CCR"
	%% set mem = slot ~ "->CMAR"
	%% set per = slot ~ "->CPAR"
	%% set length = slot ~ "->CNDTR"
	%% set prefix = "DMA_CCR"
%% endif

%% set pointer_types = [8, 16, 32]
%% for type in pointer_types
void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::memoryToPeripheral{{ type }}(uint{{ type }}_t* memory, volatile uint32_t* peripheral)
{
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::MemoryToPeripheral);
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::peripheralToMemory{{ type }}(volatile uint32_t* peripheral, uint{{ type }}_t* memory)
{
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::PeripheralToMemory);
}
void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::memoryToMemory{{ type }}(uint{{ type }}_t* m1, uint{{ type }}_t* m2)
{
	{{ mem }} = reinterpret_cast<uint32_t>(m1);
	{{ per }} = reinterpret_cast<uint32_t>(m2); // ???
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::MemoryToMemory);
}
%% if feature["double_buffer"]
void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::memoryToPeripheral{{ type }}(uint{{ type }}_t* memory1, uint{{ type }}_t* memory2, volatile uint32_t* peripheral)
{
	// TODO
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::MemoryToPeripheral);
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::peripheralToMemory{{ type }}(volatile uint32_t* peripheral, uint{{ type }}_t* memory1, uint{{ type }}_t* memory2)
{
	// TODO
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::PeripheralToMemory)
}
%% endif
%% endfor

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::reset()
{
	// TODO
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::setTransferLength(uint16_t length)
{
	{{ length }} = length;
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::setIncrement(Interface::PeripheralIncrementMode p, Interface::MemoryIncrementMode m)
{
	{{ reg }} = ({{ reg }} & ~({{ prefix }}_PINC_Msk | {{ prefix }}_MINC_Msk)) | static_cast<uint32_t>(p) | static_cast<uint32_t>(m);
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::setPriority(Interface::Priority p)
{
	uint8_t priorityValues[4] = {0b00, 0b01, 0b10, 0b11};
	{{ reg }} = ({{ reg }} & ~{{ prefix }}_PINC_Msk) | (priorityValues[static_cast<uint32_t>(p)] << {{ prefix }}_PL_Pos);
}

%% if feature["circular_mode"]
void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::setMode(Interface::Mode m)
{
	{{ reg }} &= ~{{ prefix }}_CIRC_Msk;
	switch(m) {
		case Mode::CircularMode:
			{{ reg }} |= {{ prefix }}_CIRC;
			break;
		case Mode::Normal:
		default:
			// nothing to do
			break;
	}
}
%% endif

bool
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::acquire(Interface::Context* context)
{
	(void) context;
	return true;
	// waits until isFinished() (if any transfer has ever been started)
	// stores the context once another driver acquires
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::releaseLater()
{
	// releases instantly, DMA transfer may still be active
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::stop()
{
	{{ reg }} &= ~{{ prefix}}_EN;
	while({{ reg }} & {{ prefix }}_EN); // wait for slot to be stopped
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::start()
{
	// Reset TCIF

%% if target["platform"] == "f4"
%% if slot_id <= 3
	return ({{ instance }}->LISR &= ~DMA_LISR_TCIF{{ slot_id }}); 
%% else
	return ({{ instance }}->HISR &= ~DMA_HISR_TCIF{{ slot_id }}); 
%% endif
%% else
	// TODO L4/F3/...
%% endif

	{{ reg }} |= {{ prefix}}_EN;
}

bool
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::isFinished()
{
%% if target["platform"] == "f4"
%% if slot_id <= 3
	return ({{ instance }}->LISR & DMA_LISR_TCIF{{ slot_id }}); 
%% else
	return ({{ instance }}->HISR & DMA_HISR_TCIF{{ slot_id }}); 
%% endif
%% else
	// TODO L4/F3/...
	return false;
%% endif
/* old code:
%% if target["family"] == "f4"
	return !({{ reg }} & {{ prefix }}_EN);
%% else
	return (DMA{{ id }}->ISR & DMA_ISR_TCIF{{ slot_id }});
%% endif
*/
}

void
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::connect(Interface::Peripheral p)
{
	switch(p) {
		%% for p_name, p_data in mux.items()
		case Peripheral::{{ p_name }}:
			%% set vars = {"available": False}
			%% for x in p_data
				%% if x["instance"] == id
				%% if x["slot"] == slot_id
				%% if vars.update({"available": True, "request": x["request"]})
				%% endif
				%% endif
				%% endif
			%% endfor
			%% if vars.available
			{{ reg }} = ({{ reg }} & ~{{ prefix }}_CHSEL_Msk) | ({{ vars.request }} << {{ prefix }}_CHSEL_Pos);
			%% endif
			break;
		%% endfor
		default:
			break;
	}
}

bool
modm::platform::DmaHal{{ id }}::Slot{{ slot_id }}::isAvailable(Interface::Peripheral p, Interface::FeatureMap_t features)
{
	(void) features;
	switch(p) {
		%% for p_name, p_data in mux.items()
		case Peripheral::{{ p_name }}:
			%% set vars = {"available": False}
			%% for x in p_data
				%% if x["instance"] == id
				%% if x["slot"] == slot_id
				%% if vars.update({"available": True})
				%% endif
				%% endif
				%% endif
			%% endfor
			%% if vars.available
			return true;
			%% else
			return false;
			%% endif
		%% endfor
		default:
			return false;
	}
}

%% endfor
