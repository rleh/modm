/*
 * Copyright (c) 2018, Christopher Durand
 * Copyright (c) 2018, Raphael Lehmann
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_DMAHAL{{ id }}_HPP
#	error 	"Don't include this file directly, use 'dmahal_{{ id }}.hpp' instead!"
#endif

%% if target["family"] == "f4"
	%% set streams = range(0,8)
%% elif target["family"] == "f3"
	%% if id == 1
		%% set streams = range(1,7)
	%% elif id == 2
		%% set streams = range(1,5)
	%% endif
%% endif

void
modm::platform::DmaHal{{ id }}::enable()
{
%% if target["family"] == "f4"
	RCC->AHB1ENR  |= RCC_AHB1ENR_DMA{{ id }}EN;
	RCC->AHB1RSTR |=  RCC_AHB1RSTR_DMA{{ id }}RST;
	RCC->AHB1RSTR &= ~RCC_AHB1RSTR_DMA{{ id }}RST;
%% elif target["family"] == "f3"
	RCC->AHBENR  |= RCC_AHBENR_DMA{{ id }}EN;
%% endif
}

void
modm::platform::DmaHal{{ id }}::disable()
{
%% if target["family"] == "f4"
	RCC->AHB1ENR &= ~RCC_AHB1ENR_DMA{{ id }}EN;
%% elif target["family"] == "f3"
	RCC->AHBENR &= ~RCC_AHBENR_DMA{{ id }}EN;
%% endif

}


%% for stream_id in streams

%% if target["family"] == "f4"
	%% set stream = "DMA" ~ id ~ "_Stream" ~ stream_id
	%% set reg = stream ~ "->CR"
	%% set mem = stream ~ "->M0AR"
	%% set per = stream ~ "->PAR"
	%% set length = stream ~ "->NDTR"
	%% set prefix = "DMA_SxCR"
%% elif target["family"] == "f3"
	%% set channel = "DMA" ~ id ~ "_Channel" ~ stream_id
	%% set reg = channel ~ "->CCR"
	%% set mem = channel ~ "->CMAR"
	%% set per = channel ~ "->CPAR"
	%% set length = channel ~ "->CNDTR"
	%% set prefix = "DMA_CCR"
%% endif


%% set pointer_types = [8, 16, 32]
%% for type in pointer_types
void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::memoryToPeripheral{{ type }}(uint{{ type }}_t* memory, volatile uint32_t* peripheral)
{
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::MemoryToPeripheral):
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::peripheralToMemory{{ type }}(volatile uint32_t* peripheral, uint{{ type }}_t* memory)
{
	{{ mem }} = reinterpret_cast<uint32_t>(memory);
	{{ per }} = reinterpret_cast<uint32_t>(peripheral);
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::PeripheralToMemory):
}
void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::memoryToMemory{{ type }}(uint{{ type }}_t* m1, uint{{ type }}_t* m2)
{
	{{ mem }} = reinterpret_cast<uint32_t>(m1);
	{{ per }} = reinterpret_cast<uint32_t>(m2); // ???
	{{ reg }} = ({{ reg }} & ~DataTransferDirectionMask) | static_cast<uint32_t>(DataTransferDirection::MemoryToMemory):
}
%% endfor

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::stop()
{
%% if target["family"] == "f4"
	{{ reg }} &= ~DMA_SxCR_EN;
	while({{ reg }} & DMA_SxCR_EN); // wait for stream to be stopped
%% else
	{{ reg }} &= ~DMA_CCR_EN;
	while({{ reg }} & DMA_CCR_EN); // wait for stream to be stopped
%% endif
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::start()
{
%% if target["family"] == "f4"
	{{ reg }} |= DMA_SxCR_EN;
%% else
	// clear interrupt flags
	DMA{{ id }}->ISR |= DMA_ISR_TEIF{{ stream_id }} |
						DMA_ISR_TCIF{{ stream_id }} |
						DMA_ISR_HTIF{{ stream_id }} |
						DMA_ISR_GIF{{ stream_id }};
	{{ reg }} |= DMA_CCR_EN;
%% endif
}

bool
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::isFinished()
{
%% if target["family"] == "f4"
	return !({{ reg }} & DMA_SxCR_EN);
%% else
	return (DMA{{ id }}->ISR & DMA_ISR_TCIF{{ stream_id }});
%% endif
}


// TODO below

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::setTransferLength(uint16_t length)
{
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::setIncrement(PeripheralIncrementMode p, MemoryIncrementMode m)
{
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::setPriority(Priority p)
{
}

%% if target["family"] == "f4"
// every f4?
void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::setMode(Mode m)
{
}
%% endif

bool
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::acquire(Context* context)
{
	// waits until isFinished() (if any transfer has ever been started)
	// stores the context once another driver acquires
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::release()
{
	// releases instantly, DMA transfer may still be active
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::stop()
{
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::start()
{
}

bool
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::isFinished()
{
}

void
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::connect(Peripheral p)
{
	switch(p) {
		case Spi1Tx:
		break;
	}
}

bool
modm::platform::DmaHal{{ id }}::Stream{{ stream_id }}::isAvailable(Peripheral p)
{
	switch(p) {
		case Spi1Tx:
			[[fallthrough]]
		case Uart3Tx:
			return true;
		default:
			return false;
	}
}

%% endfor
