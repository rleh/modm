/*
 * Copyright (c) 2014, Kevin LÃ¤ufer
 * Copyright (c) 2014-2017, Niklas Hauser
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#ifndef MODM_STM32_DMA{{ id }}_HPP
#define MODM_STM32_DMA{{ id }}_HPP

#include <stdint.h>
#include "../device.hpp"
#include "dma_base.hpp"

/**
 * @ingroup 	{{partname}}
 * @defgroup	{{partname}}_dma DMA
 */

%% if target["family"] == "f4"
	%% set streams = range(0,8)
%% elif target["family"] == "f3"
	%% if id == 1
		%% set streams = range(1,7)
	%% elif id == 2
		%% set streams = range(1,5)
	%% endif
%% endif

namespace modm::platform
{

/**
 * DMA
 *
 * Does not support - among other things - double buffering or FIFO usage
 *
 * @author	Kevin Laeufer
 * @ingroup	{{partname}}_dma
 */
class DmaHal{{ id }}
{
public:
	static inline void
	enable();

	static inline void
	disable();


public:
%% for stream in streams
	class Stream{{ stream }} : public DmaBase
	{
	public:
		using Context = ;

		static void
		connect<>();

		static void
		reset();

		template<typename T>
		static void
		memoryToPeripheral(modm::disable_deduction_t<T*> memory, modm::disable_deduction_t<T*> peripheral);

		template<typename T>
		static void
		peripheralToMemory(modm::disable_deduction_t<T*> peripheral, modm::disable_deduction_t<T*> memory);

		template<typename T>
		static void
		memoryToMemory(modm::disable_deduction_t<T*> memory, modm::disable_deduction_t<T*> memory);

		static void
		setTransferLength(uint16_t length);

		static void
		setIncrement(PeripheralIncrementMode p, MemoryIncrementMode m);

		static void
		setPriority(Priority p);

		%% if target["family"] == "f4"
		static constexpr bool hasBurstTransfer = true;
		static void
		setBurstTransfer(PeripheralBurstTransfer p, MemoryBurstTransfer m);
		%% else
		static constexpr bool hasBurstTransfer = false;
		%% endif

		%% if target["family"] == "f4"
		static constexpr bool hasFlowControl = true;
		static void
		setBurstTransfer(FlowControl f);
		%% else
		static constexpr bool hasFlowControl = false;
		%% endif

		%% if target["family"] == "f4"
		// every f4?
		static constexpr bool hasCircularMode = true;
		static constexpr bool hasDoubleBufferMode = true;
		enum class Mode : uint32_t {
			Normal = 0,
			CircularMode = DMA_SxCR_CIRC,
			DoubleBufferMode = DMA_SxCR_DBM,
		}
		static constexpr uint32_t ModeMask = DMA_SxCR_CIRC | DMA_SxCR_DBM;
		%% else
		static constexpr bool hasCircularMode = false;
		static constexpr bool hasDoubleBufferMode = false;
		%% endif

		static bool
		acquire(Context* context);
		// waits until isFinished() (if any transfer has ever been started)
		// stores the context once another driver acquires

		static void
		release();
		// releases instantly, DMA transfer may still be active

		static inline void
		stop();

		static inline void
		start();

		static inline bool
		isFinished();

		template<uint32_t channel>
		static inline bool
		connect();
	};
%% endfor
};

}	// namespace modm::platform

#include "dma_{{ id }}_impl.hpp"

#endif	// MODM_STM32_DMA{{ id }}_HPP
